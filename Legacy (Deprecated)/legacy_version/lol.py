import requests
import csv
import json
import os
import time

# --- Configuration ---
# The CSV file generated by the previous script, containing module codes.
INPUT_CSV_FILE = "nus_modules.csv"
# The new CSV file to store the detailed module information.
OUTPUT_CSV_FILE = "nus_modules_detailed.csv"
# The API endpoint template for fetching detailed module data.
API_URL_TEMPLATE = "https://api.nusmods.com/v2/2025-2026/modules/{}.json"
# Headers for the new CSV file, based on the provided schema.
CSV_HEADERS = [
    "moduleCode", "title", "description", "moduleCredit", "workload",
    "prerequisite", "preclusion", "acadYear", "department", "faculty",
    "semesterData", "prereqTree", "fulfillRequirements"
]

def fetch_and_save_detailed_module_data():
    """
    Reads module codes from a CSV, fetches detailed data for each from an API,
    and saves the results to a new CSV file.
    """
    # --- Step 1: Read module codes from the input CSV ---
    if not os.path.exists(INPUT_CSV_FILE):
        print(f"Error: Input file not found at '{INPUT_CSV_FILE}'.")
        print("Please run the previous script first to generate it.")
        return

    module_codes = []
    try:
        with open(INPUT_CSV_FILE, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                if 'moduleCode' in row:
                    module_codes.append(row['moduleCode'])
    except (IOError, csv.Error) as e:
        print(f"Error reading {INPUT_CSV_FILE}: {e}")
        return

    if not module_codes:
        print("No module codes found in the input file.")
        return

    print(f"Found {len(module_codes)} module codes to process.")

    # --- Step 2: Fetch detailed data for each module code ---
    all_modules_data = []
    total_modules = len(module_codes)
    for i, code in enumerate(module_codes):
        api_url = API_URL_TEMPLATE.format(code)
        print(f"[{i+1}/{total_modules}] Fetching data for {code}...")

        try:
            response = requests.get(api_url)
            response.raise_for_status()  # Raise an exception for bad status codes
            
            module_data = response.json()

            # Prepare the row for the CSV, converting complex types to JSON strings
            processed_row = {
                "moduleCode": module_data.get("moduleCode"),
                "title": module_data.get("title"),
                "description": module_data.get("description"),
                "moduleCredit": module_data.get("moduleCredit"),
                "prerequisite": module_data.get("prerequisite"),
                "preclusion": module_data.get("preclusion"),
                "acadYear": module_data.get("acadYear"),
                "department": module_data.get("department"),
                "faculty": module_data.get("faculty"),
                # Convert lists/dicts to a compact JSON string for CSV storage
                "workload": json.dumps(module_data.get("workload")) if module_data.get("workload") else None,
                "semesterData": json.dumps(module_data.get("semesterData")) if module_data.get("semesterData") else None,
                "prereqTree": json.dumps(module_data.get("prereqTree")) if module_data.get("prereqTree") else None,
                "fulfillRequirements": json.dumps(module_data.get("fulfillRequirements")) if module_data.get("fulfillRequirements") else None,
            }
            all_modules_data.append(processed_row)
            
            # Be a good API citizen: add a small delay to avoid overwhelming the server
            time.sleep(0.1)

        except requests.exceptions.RequestException as e:
            print(f"  -> Failed to fetch data for {code}. Error: {e}")
        except json.JSONDecodeError:
            print(f"  -> Failed to parse JSON response for {code}.")

    # --- Step 3: Write the collected data to the output CSV ---
    if not all_modules_data:
        print("No data was successfully fetched. The output file will not be created.")
        return

    try:
        with open(OUTPUT_CSV_FILE, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=CSV_HEADERS)
            writer.writeheader()
            writer.writerows(all_modules_data)
        print(f"\nSuccessfully saved detailed data for {len(all_modules_data)} modules to '{os.path.abspath(OUTPUT_CSV_FILE)}'.")
    except IOError as e:
        print(f"Error writing to CSV file: {e}")


if __name__ == "__main__":
    fetch_and_save_detailed_module_data()